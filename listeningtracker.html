<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Listening Tracker</title>
<style>
  :root {
    --bg:#ffffff; --text:#000; --muted:#555;
    --primary:#007bff; --finish:#ff8800; --card:#fafafa;
  }
  html, body {
    margin:0; height:100%; background:var(--bg); color:var(--text);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  .screen { display:none; min-height:100%; display:flex; align-items:center; justify-content:center; }
  .wrap {
    width:min(720px,92vw); background:var(--card); border:1px solid #eee;
    border-radius:16px; padding:24px; box-shadow:0 10px 30px rgba(0,0,0,.08);
  }
  h1 { margin:0 0 12px; font-size:1.4rem; }
  p { margin:.2rem 0 .8rem; color:var(--muted); }
  input[type=text] {
    width:100%; padding:12px 14px; font-size:16px; border:1px solid #ccc; border-radius:10px;
  }
  button {
    border:none; border-radius:12px; padding:14px 0; font-size:16px; cursor:pointer; font-weight:600;
  }
  .btn-speed { background:var(--primary); color:#fff; }
  .btn-start { background:var(--primary); color:#fff; width:160px; }
  .btn-finish { background:var(--finish); color:#fff; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .mt { margin-top:12px; }
  audio { width:100%; margin:12px 0 8px; }
  .grid { display:grid; gap:10px; grid-template-columns: repeat(4, 1fr); }
  @media (max-width:560px){ .grid { grid-template-columns: repeat(3, 1fr);} }
</style>
</head>
<body>

<!-- START SCREEN -->
<div id="startScreen" class="screen" style="display:flex">
  <div class="wrap">
    <h1>Listening Tracker</h1>
    <p>Paste a <b>direct MP3 URL</b>. This site will log listening events and download them as a CSV file.</p>
    <div class="row">
      <input id="mp3Url" type="text" placeholder="https://example.com/file.mp3" style="flex:1;" />
      <button id="startBtn" class="btn-start" disabled>Start</button>
    </div>
  </div>
</div>

<!-- PLAYER SCREEN -->
<div id="playerScreen" class="screen">
  <div class="wrap">
    <h1 id="title" style="margin-bottom:4px;">Player</h1>
    <p id="hint" style="margin-top:0; font-size:.95rem;"></p>
    <audio id="audio" controls></audio>
    <div class="grid mt" id="speedGrid">
      <button class="btn-speed" data-speed="0.5">0.5×</button>
      <button class="btn-speed" data-speed="0.75">0.75×</button>
      <button class="btn-speed" data-speed="1">1×</button>
      <button class="btn-speed" data-speed="1.25">1.25×</button>
      <button class="btn-speed" data-speed="1.5">1.5×</button>
      <button class="btn-speed" data-speed="1.75">1.75×</button>
      <button class="btn-speed" data-speed="2">2×</button>
      <button id="finishBtn" class="btn-finish">Finish</button>
    </div>
  </div>
</div>

<script>
/* ---------- Elements ---------- */
const startScreen = document.getElementById('startScreen');
const playerScreen = document.getElementById('playerScreen');
const urlInput = document.getElementById('mp3Url');
const startBtn = document.getElementById('startBtn');
const audio = document.getElementById('audio');
const finishBtn = document.getElementById('finishBtn');
const hint = document.getElementById('hint');

/* ---------- State ---------- */
let mp3Url = '';
let logRows = [];                // rows match HEADER order
let totalListen = 0;             // seconds while actually playing (wall-clock)
let lastPlayT = null;            // epoch ms when play last started/resumed
let firstPlayAt = null;          // epoch ms of first real play
let finishedAt = null;           // epoch ms when Finish clicked

// Unique coverage tracker: which integer seconds of the audio have been heard
let uniqueSecondsHeard = new Set();
let prevPos = null;              // previous playback position to fill coverage between updates

const HEADER = [
  "mp3_url","event_type","timestamp","audio_time_sec",
  "playback_speed","total_listen_time_sec","completion_percent"
];

/* ---------- Helpers ---------- */
function looksLikeMP3(u){
  try { const x = new URL(u); return x.pathname.toLowerCase().endsWith('.mp3'); }
  catch(e){ return false; }
}
urlInput.addEventListener('input', ()=> startBtn.disabled = !looksLikeMP3(urlInput.value.trim()));

/* Human-readable, comma-free timestamp: YYYY-MM-DD HH:MM:SS */
function nowTS(){
  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  const Y = d.getFullYear();
  const M = pad(d.getMonth()+1);
  const D = pad(d.getDate());
  const h = pad(d.getHours());
  const m = pad(d.getMinutes());
  const s = pad(d.getSeconds());
  return `${Y}-${M}-${D} ${h}:${m}:${s}`;
}
function fmt(n){ return Number.isFinite(n) ? n.toFixed(2) : ""; }
function csvEscape(v){
  const s = String(v ?? "");
  if (/[",\r\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
  return s;
}
function pushLog(type){
  const at = audio.currentTime || 0;
  const dur = audio.duration || 0;
  const completionInstant = dur>0 ? (at/dur)*100 : 0; // per-event, not unique coverage
  const row = [ mp3Url, type, nowTS(), fmt(at), fmt(audio.playbackRate||1), fmt(totalListen), fmt(completionInstant) ];
  logRows.push(row);
}
function accountListening(){
  if (lastPlayT !== null) {
    totalListen += (Date.now() - lastPlayT)/1000;
    lastPlayT = Date.now();
  }
}

/* Add coverage between two positions (inclusive of integer seconds crossed) */
function addCoverage(from, to){
  if (!Number.isFinite(from) || !Number.isFinite(to)) return;
  let start = Math.min(from, to);
  let end   = Math.max(from, to);
  let s = Math.floor(start);
  let e = Math.floor(end);
  for (let t = s; t <= e; t++) uniqueSecondsHeard.add(t);
}

/* ---------- Start ---------- */
startBtn.addEventListener('click', ()=>{
  mp3Url = urlInput.value.trim();
  audio.src = mp3Url;
  hint.textContent = mp3Url;
  startScreen.style.display = 'none';
  playerScreen.style.display = 'flex';
});

/* ---------- Events ---------- */
audio.addEventListener('play', ()=>{
  if (firstPlayAt === null) firstPlayAt = Date.now();
  lastPlayT = Date.now();
  prevPos = audio.currentTime;
  pushLog('play');
});
audio.addEventListener('pause', ()=>{
  // On pause, add coverage since last position update while it was playing
  addCoverage(prevPos ?? audio.currentTime, audio.currentTime);
  accountListening();
  lastPlayT = null;
  pushLog('pause');
});

// Track position updates for coverage
audio.addEventListener('timeupdate', ()=>{
  // timeupdate fires during playback as position advances (and after seeks)
  if (prevPos === null) { prevPos = audio.currentTime; return; }
  // Only add coverage while playing
  if (!audio.paused) addCoverage(prevPos, audio.currentTime);
  prevPos = audio.currentTime;
});

// Speed buttons (in-grid)
document.getElementById('speedGrid').addEventListener('click', (e)=>{
  const btn = e.target.closest('button[data-speed]');
  if(!btn) return;
  const s = parseFloat(btn.getAttribute('data-speed'));
  // Add coverage up to this instant before changing rate
  addCoverage(prevPos ?? audio.currentTime, audio.currentTime);
  accountListening();
  audio.playbackRate = s;
  pushLog('speed_change');
});

// Seek tracking
audio.addEventListener('seeking', ()=>{
  // Count coverage up to the moment seeking started
  addCoverage(prevPos ?? audio.currentTime, audio.currentTime);
  accountListening();
});
audio.addEventListener('seeked', ()=>{
  // After seeking, reset prevPos to new location
  prevPos = audio.currentTime;
  pushLog('seek');
  if (!audio.paused) lastPlayT = Date.now();
});

finishBtn.addEventListener('click', ()=>{
  // Finalize coverage & listening time
  addCoverage(prevPos ?? audio.currentTime, audio.currentTime);
  accountListening();
  finishedAt = Date.now();
  pushLog('finish');
  downloadCSV();
  finishBtn.disabled = true; // avoid double downloads
});

/* ---------- CSV ---------- */
function downloadCSV(){
  const lines = [];
  lines.push(HEADER.join(','));
  for(const row of logRows) lines.push(row.map(csvEscape).join(','));

  // Footer row: total listening duration (firstPlayAt → finishedAt) + TRUE completion from unique heard seconds
  if (firstPlayAt !== null && finishedAt !== null) {
    const deltaSec = (finishedAt - firstPlayAt) / 1000;
    const dur = audio.duration || 0;
    const totalSeconds = Math.max(1, Math.ceil(dur)); // guard divide-by-zero
    const uniqueHeard = Math.min(uniqueSecondsHeard.size, totalSeconds);
    const trueCompletion = dur > 0 ? (uniqueHeard / totalSeconds) * 100 : 0;
    // Put label in first column, total seconds in audio_time_sec column, completion in last column
    const footer = ['total listening duration', '', '', fmt(deltaSec), '', '', fmt(trueCompletion)];
    lines.push(footer.map(csvEscape).join(','));
  }

  const BOM = '\uFEFF';
  const csvText = BOM + lines.join('\r\n');
  const blob = new Blob([csvText], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'listening_log.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>